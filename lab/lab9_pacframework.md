**Розробка і імітаційне моделювання інтегрованих систем керування. Лабораторний практикум. ** Автор і лектор: Олександр Пупена 

# Лабораторна робота №9. Розробка системи керування з використанням каркасу

**Тривалість**: 4 акад. години.

**Мета:** Навчитися розробляти застосунки для програмованих контролерів з використанням каркасу PACFramework

**Лабораторна установка**

- Апаратне забезпечення: ПК
- Програмне забезпечення: UNITY PRO V>=7.0 або Control Expert, Node-RED, хмарні застосунки Google Sheet, сервіси Telegram

## Порядок виконання роботи 

У цій лабораторній роботі необхідно розробити базові рівні керування для ПЛК з використанням каркасу PACFramework. 

**Увага!** Для виконання лабораторної роботи необхідне встановлене ПЗ [Unity PRO](https://schneider-electric.app.box.com/s/lgd27nur1rin1hs4x822g8lr6tlr2y82/folder/50504496333) або [Control Expert](https://schneider-electric.app.box.com/s/lgd27nur1rin1hs4x822g8lr6tlr2y82/folder/101662336138). За наведеними посиланнями знаходяться пробні версії з ключом активації на 60 діб. Після завершення терміну дане ПЗ більше не буде запускатися навіть після перевстановлення. Тому рекомендується встановлювати його на віртуальну машину. Мінімальна версія потрібного [UnityPro_XL_V7.0](https://schneider-electric.app.box.com/s/lgd27nur1rin1hs4x822g8lr6tlr2y82/folder/50505220340) у цій роботі  використовується [Unity PRO 13.1](https://schneider-electric.app.box.com/s/lgd27nur1rin1hs4x822g8lr6tlr2y82/folder/71210166883)

## 1. Підготовка програми імітації об'єкту

###  1.1. Завантаження експортного варіанту проекту з імітацією

- [ ] Завантажте на диск файл `sim_wthout_framework.xef` за [цим посиланням](https://github.com/pupenasan/PACFramework/blob/master/platforms/unitypro/sim_wthout_framework.xef)

![image-20220112174305839](media9/image-20220112174221929.png)

Рис.9.1. Завантаження проекту імітатора з репозиторію

- [ ] Запустіть на виконання середовище UNITY PRO. 
- [ ] Використовуючи меню `File->Open` та вказавши формат `Unity PRO Application Exchange`, відкрийте проект  `sim_wthout_framework.xef` . 
- [ ] Перейдіть в режим імітації ПЛК: `PLC -> Simulation Mode`
- [ ] Зробіть компіляцію проекту `Build -> Rebuild All Project`.
- [ ] Збережіть проект у форматі STU на диску для наступного його використання.
- [ ] З'єднайтеся з імітатором ПЛК: `PLC->Connect`. У результаті повинен запуститися імітатор ПЛК.
- [ ] Завантажте проект в імітатор ПЛК: `PLC->Transfer Project to PLC`
- [ ] Запустіть на виконання програму в імітаторі: `PLC->RUN`. 

### 1.2. Ознайомлення з імітатором об'єкту керування  

Для швидшої розробки навчального проекту пропонується використовувати заздалегідь підготовлений проект з імітацією установки приготування продукту в ємностях (надалі **установка приготування**). Проект включає операторський екран UNITY PRO для відображення/керування відділеннями (рис.9.2).

Технологічна установка приготування складається з наступних елементів (рис.3):

1) танки Т1 та Т2, в яких готовляться продукти за різними рецептами; танки обв’язані наступними засобами КВПіА:

- запірні клапани набору та зливу, кожний з датчиками кінцевого положення "закритий" та "відкритий";
- регулюючий клапан (0-100%) подачі теплоагента у теплообмінний кожух танку (далі по тексту клапан нагрівання);
- датчик рівня (0-100%) в танку;
- датчик температури в танку (0-100°С);
- привід мішалки танку 

2) дозатори (мірні ємності) D1 та D2, які забезпечують подачу дози компоненту; дозатори обв’язані наступними засобами КВПіА:

- сигналізатор нижнього і верхнього рівнів;

- запірні клапани набору та зливу, кожний з датчиками кінцевого положення "закритий";

3) 3-ходовий клапан перемикання трубопроводу подачі з дозаторів на танки T1 та T2; в нормальному стані положення "на Т1"; має датчики кінцевого положення "Т1" та "Т2".

![image-20220112180836855](media9/image-20220112180836855.png)

Рис.9.2. Зовнішній вигляд програми вікна керування 

### 1.3. Перевірка роботи імітованого об'єкту 

- [ ] Перейдіть в розділ `Operator Screens->Tanks`
- [ ] Натисніть на вільному місці екрану,  викличте в меню в меню `Services->Enable write variable ` (див.рис.9.2)

- [ ] перевірте роботу усіх клапанів:
  - запірних, натискаючи на кнопку біля клапану  
  - регулюючих (подача теплоагента), вказуючи в поле для вводу біля клапану ступінь відкриття у % і натискаючи `Enter`
- [ ] Подивіться на реакцію датчиків положення та імітацію роботи об’єкту керування. Зверніть увагу на те, що деякі клапани мають два датчика положення, а деякі тільки один. 
- [ ] Виділіть усі об'єкти (Ctrl+A), викличте контекстне меню (права кнопка миші) і виберіть пункт `Initialize Animation Table`
- [ ] Подивіться до яких змінних прив'язані об'єкти

### 1.4. Опис функцій та алгоритму задач керування установкою 

- [ ] Ознайомтеся з наведеним нижче описом функцій та задач керування установкою.

Передбачається що в демонстраційному проекті будуть виконуватися наступні функції.  

1) Виконання задачі приготування відповідно до наведеного нижче опису;

2) У будь який момент часу система має можливість переходу в початковий стан (крок) за допомогою команди "Ініціалізація кроків". 

4) Типові функції передбачені каркасом.


Передбачається що в демонстраційному проекті будуть виконуватися наступні задачі.  

Керування дозаторами та танками розв’язане одне від одного (але координоване), оскільки дозатори можуть бути використані в інших процесах. Дозатори в стані очікування завжди наповнені. 

Керування процесом приготування відбувається за таким алгоритмом (вбудована процедура технологічної комірки):

1) У початковому стані (старті ПЛК) клапани набору та зливу танків Т1 та Т2 закриваються. Закритість клапанів контролюється кінцевими датчиками положення. Після цього система керування установкою приготування переходить в стан очікування.

2) Оператор повинен задати рецепт продукту для приготування в Т1 та Т2. Рецепт включає наступні поля:

- кількість доз компоненту з D1;

- кількість доз компоненту з D2;

- температуру попереднього нагрівання;

- час витримки;

3) Після натискання оператором кнопки "Пуск" відкривається клапан набору танку Т1.

4) Після досягнення рівня 50% паралельно з набором включається дозування компонентів D1 та D2 відповідно до рецепту. 

5) При досягненні рівня 80%, відкривається клапан набору танку Т2.

6) Коли клапан набору Т2 повністю відкрився (по датчику положення "відкритий"), клапан набору Т1 закривається, і паралельно з приготуванням продукту в Т1 йде наповнення і приготування продукту в танку Т2.

7) При досягненні рівня 50% в Т2 паралельно з набором включається дозування компонентів D1 та D2 відповідно до рецепту. Якщо дозатор в цей час використовується при дозуванні Т1, необхідно дочекатися закінчення роботи дозаторів.

8) При досягненні рівня 80%, закривається клапан набору танку Т2.

9) Після закриття клапану набору в танку Т1 (в наступних пунктах для Т2 аналогічно) і закінченні дозування, відкривається повністю клапан подачі теплоагента; 

10) Рідина в танках нагрівається до вказаного в рецепті значення, після чого клапан залишається відкритий на 10% протягом вказаного в рецепті часу;

11) Після витримки відкривається клапан зливу і рідина зливається з танку;

12) Через 5с після досягнення рівня менше ніж 1% клапан зливу закривається;

13) Коли обидва танки Т1 та Т2 порожні, система переходить в початковий стан.

За необхідності передбачається використання Batch Control з можливістю динамічного створення своїх процедур. 

## 2. Розгортання PLCFN та створення програми користувача

У цьому розділі необхідно розгорнути в проекті PLCFN.

### 2.1. Ознайомлення та завантаження PLCFN

- [ ] Ознайомтеся з призначенням та принципами функціонування  PLCFN за [даним посиланням](https://github.com/pupenasan/PACFramework/blob/master/cm/2_plcfn.md)
- [ ] Завантажте експортний варіант функціонального блоку `plcfn.xdb` за [цим посиланням](https://github.com/pupenasan/PACFramework/blob/master/platforms/unitypro/plcfn.xdb)
- [ ] Завантажте експортний варіант операторського екрану  

### 2.2. Імпорт PLCFN та створення змінної

- [ ] Імпортуйте завантажений DFB `plcfn.xdb`

![image-20220113160428036](media9/image-20220113160428036.png)

Рис.9.3. Імпорт DFB

- [ ] Перегляньте, разом з DFB імпортується також структура PLC_CFG
- [ ] Створіть змінну `PLC` типу `PLC_CFG`

![image-20220113162001765](C:\Users\san\AppData\Roaming\Typora\typora-user-images\image-20220113162001765.png)

рис.9.4. Створення змінної PLC

### 2.2. Створення основної секції

- [ ] Створіть секцію `Main`

![image-20220113161047578](media9/image-20220113161047578.png)

Рис.9.5. Створення секції Main

- [ ] В секцію в Main помістіть виклик DFB `PLCFN` однойменного типу 

![image-20220113162900408](media9/image-20220113162900408.png)

Рис.9.6. Виклик DFB (та його створення) PLC в секції Main.

Зверніть увагу, що автоматично буде створено екземпляр функціонального блоку `PLCFN`.

### 2.3. Імпорт операторського екрану

- [ ] Завантажте за [цим](https://github.com/pupenasan/PACFramework/tree/master/platforms/unitypro) посиланням та імпортуйте в проект операторський екран `plc.xcr`

## 3. Розгортання рівня каналів

### 3.1. Імпорт CM LVL0 (каналів) 

- [ ] Завантажте файл експорту екземплярів функціональних блоків `chfns.xsy` за [цим посиланням](https://github.com/pupenasan/PACFramework/blob/master/platforms/unitypro/chfns.xsy)
- [ ] Імпортуйте екземпляри та типи в проект (Variables & FB Instancess -> Import). При імпорті з'явиться вікно  повідомлення про необхідність заміни, в якому треба натиснути `Keep All` (рис.9.7) для збереження усіх існуючих в проекті об'єктів (PLC_CFG). 

![image-20220117142111154](media9/image-20220117142111154.png)

Рис.9.7. Вікно підтвердження/відхилення заміни обєктів

### 3.2 Cтворення змінних каналів 

- [ ] Подивіться уважно конфігурацію наявного обладнання. Визначте скільки дискретних та аналогових входів та виходів доступні в конфігурації. Впишіть ці значення в значення за замовченням змінних `PLC.DICNT`, `PLC.AICNT` , `PLC.DOCNT`, `PLC.AOCNT`: 

![image-20220117165655046](media9/image-20220117165655046.png) 

Рис.9.8. Налаштування кількості змінних

- [ ] Створіть змінні - масиви відповідних типів для забезпечення роботи каналів з конфігураційними параметрами (CFG) та (HMI)

![image-20220117172450485](media9/image-20220117172450485.png)

рис.9.10. Змінні для каналів

- [ ] Створіть змінну `CH_BUF` типу `CH_BUF` для роботи з буфером.
- [ ] Створіть змінну `i` типу `INT`

 ### 3.3. Створення та виклик секцій обробки вхідних каналів

- [ ] Створіть підпрограми (SR Section) на мові ST з іменами `inputs` та `outputs` 
- [ ] У секції `main` викличте ці дві секції. Тепер Ваша програма має наступний вигляд:

```pascal
PLCFN (PLC := PLC);
inputs();
outputs();
```

- [ ] У секції  `inputs`  створіть наступний фрагмент програми користувача:

```pascal
FOR i := 1 TO PLC.DICNT DO
    (*на першому циклі ініціалізуємо змінні ID + CLSID*)
    IF PLC.STA_SCN1 THEN
        CHDI[i].ID := INT_TO_UINT(i);
        IF CHDI[i].CLSID = 0 THEN CHDI[i].CLSID := 16#0010;END_IF;
    END_IF;
END_FOR;

CHDIFN (RAW := %i0.1.0,  CHCFG := CHDI[1],  CHHMI := CHDI_HMI[1],  PLCCFG := PLC, CHBUF := CH_BUF);
(*тут має бути виклик обробки інших каналів DI*)

FOR i := 1 TO PLC.AICNT DO
    (*на першому циклі ініціалізуємо змінні ID + CLSID*)
    IF PLC.STA_SCN1 THEN
        CHAI[i].ID := INT_TO_UINT(i);
        IF CHAI[i].CLSID = 0 THEN CHAI[i].CLSID := 16#0030;END_IF;
    END_IF;
END_FOR;

CHAIFN (RAWINT := %IW0.2.0, CHCFG := CHAI[1], CHHMI := CHAI_HMI[1], PLCCFG := PLC, CHBUF := CH_BUF);
(*тут має бути виклик обробки інших каналів AI*)
```

- [ ] Проаналізуйте код фрагменту програми. Він складається з 4-х частин. У 2-х з них виставляється CLSID за замовченням у тому випадку, якщо він не визначений для конкретної змінної каналу. У 2-х інших обробляється по одному каналу з кожної змінної. Обробку усіх інших каналів необхідно буде добавити самостійно. 
- [ ] Скористайтеся засобами редагування таблиць (наприклад Excel) для формування обробки інших каналів. Для цього, наприклад, можна зробити наступні дії:

- [ ] - [ ] скопіювати в блокнот код, який необхідно "розмножати":

  - [ ] ```pascal
    CHDIFN (RAW := %i0.1.0,  CHCFG := CHDI[1],  CHHMI := CHDI_HMI[1],  PLCCFG := PLC, CHBUF := CH_BUF);
    ```

  - [ ] поставити знаки табуляції між частинами, які будуть змінними:

  - [ ] ```
    CHDIFN (RAW := %i	0.1.0	,  CHCFG := CHDI[	1	],  CHHMI := CHDI_HMI[	1	],  PLCCFG := PLC, CHBUF := CH_BUF);
    ```

  - [ ] скопіювати даний код в електронну таблицю;

  - [ ] використовуючи вбудовані функції електронних таблиць зробити аналогічні виклики для наступних вхідних каналів, наприклад, як наведено на наступному рисунку

![image-20220117171347858](media9/image-20220117171347858.png) 

рис.9.9. Вигляд заповнення електронної таблиці 

- [ ] Скопіюйте дані з електронної таблиці в блокнот. За допомогою функцію пошуку та заміни замініть знаки табуляції на порожній символ, тобто видаліть усі знаки табуляції. Текст що вийшов буде вашим фрагментом програми.

  ### 3.4. Створення та виклик секцій обробки вхідних каналів

- [ ] Аналогічно попередньому пункту в секції `outputs` створіть обробку вихідних каналів 

```pascal
FOR i := 1 TO PLC.DOCNT DO
    (*на першому циклі ініціалізуємо змінні ID + CLSID*)
    IF PLC.STA_SCN1 THEN
        CHDO[i].ID := INT_TO_UINT(i);
        IF CHDO[i].CLSID = 0 THEN CHDO[i].CLSID := 16#0020;END_IF;
    END_IF;
END_FOR;

CHDOFN (CHCFG := CHDO[1],  CHHMI := CHDO_HMI[1],  PLCCFG := PLC, CHBUF := CH_BUF, RAW => %Q0.1.16);
(*тут має бути виклик обробки інших каналів DO*)

FOR i := 1 TO PLC.AOCNT DO
    (*на першому циклі ініціалізуємо змінні ID + CLSID*)
    IF PLC.STA_SCN1 THEN
        CHAO[i].ID := INT_TO_UINT(i);
        IF CHAO[i].CLSID = 0 THEN CHAO[i].CLSID := 16#0040;END_IF;
    END_IF;
END_FOR;

CHAOFN (CHCFG := CHAO[1], CHHMI := CHAO_HMI[1], PLCCFG := PLC, CHBUF := CH_BUF, RAWINT => %QW0.2.4);
(*тут має бути виклик обробки інших каналів AO*)
```

- [ ] Зробіть тест на помилки проекту (Build -> Analyze) для перевірки коректності проведених дій та виправте помилки

### 3.5. Створення PLCMAPS

- [ ] завантажте за [цим](https://github.com/pupenasan/PACFramework/tree/master/platforms/unitypro) посиланням та імпортуйте в проект типи `module.xdd` і `submodule.xdd`, при конфліктах типів збережіть ті, що в проекті  
- [ ] Створіть змінну `MODULES` типу `ARRAY[0..3] OF MODULE`, яка буде відповідати за інформацію про модулі
- [ ] Створіть змінну `SUBMODULE` типу `SUBMODULE`, яка буде відповідати за підмодуль, який зараз в буфері
- [ ] Створіть SR секцію с назвою `plcmaps`, яка буде відображати активну інформацію за замовченням. Ця секція не є обов'язковою, так як ті ж параметри можна задати за замовченням для змінних. Вона радше потрібна для того, щоб ініціалізувати змінні за необхідності програмним шляхом.
- [ ] Запишіть в секцію наступний фрагмент програми 

```pascal
(*кількість каналів та модулів*)
PLC.DICNT := 32;
PLC.DOCNT := 32;
PLC.AICNT := 8;
PLC.AOCNT := 4;
PLC.MODULSCNT := 8;

(*завантажити в буфер підмодуль 0 модуля 0*)
MODULES[0].STA.11 := true;
(*0.1-DDM3202K*)
(*типи 1- DICH, 2- DOCH, 3- AICH, 4 – AOCH, 5 - COM*)
MODULES[0].TYPE1 := 16#1200; (*DI+DO*)
(*кількість каналів на кожен Submodule, комбінація в 16-ковому форматі 
- 1 (16#XYZQ) X - для першого субмодуля*)
MODULES[0].CHCNTS := 16#ff00;(*16 + 16*)
MODULES[0].STRTNMB[0] := 1;(*DI*)
MODULES[0].STRTNMB[1] := 1;(*DO*)
MODULES[0].STRTNMB[2] := 0;
MODULES[0].STRTNMB[3] := 0;

(*0.2-AMM0600*)
MODULES[1].TYPE1 := 16#3400;(*AI + AO*) 
MODULES[1].CHCNTS := 16#3100;(*16 + 16*)
MODULES[1].STRTNMB[0] := 1;(*AI*)
MODULES[1].STRTNMB[1] := 1;(*AO*)
MODULES[1].STRTNMB[2] := 0;
MODULES[1].STRTNMB[3] := 0;
```

- [ ] Допишіть секцію кодом з реалізацією відображення каналів ще для 2-х модулів (0.3 та 0.4)

### 3.6. Обробка Moduls

- [ ] Завантажте за [цим](https://github.com/pupenasan/PACFramework/tree/master/platforms/unitypro) посиланням та імпортуйте в проект SR секцію `moduls.xst`, при конфліктах типів збережіть ті, що в проекті  
- [ ] Модифікуйте програму в секції `main` щоб при старті програми запускалася секція `plcmaps`, а також викликалася секція обробки модулів `moduls`. Секція матиме вигляд: 

```pascal
PLCFN (PLC := PLC);
(*виклик при старті*)
IF PLC.STA_SCN1 THEN
  plcmaps();
END_IF;
inputs();
outputs();
moduls();
```

- [ ] Зробіть компіляцію проекту і завантажте в імітатор ПЛК.

### 3.7. Розробка операторських екранів

- [ ] Завантажте за [цим](https://github.com/pupenasan/PACFramework/tree/master/platforms/unitypro) посиланням та імпортуйте в проект операторський екран `moduls.xcr`

![image-20220118174132830](media9/image-20220118174132830.png)

рис.9.10. Зовнішній вигляд операторського екрану для налагодження роботи з каналами на один модуль

- [ ] Цей операторський екран має тільки один модуль. Інші треба доробити самостійно. Для цього рекомендується використовувати XML редактор. Створіть новий операторський екран, куди скопіюйте групу з першим модулем. Зробіть ще три копії поряд. Екран матиме наступний вигляд.

![image-20220118181550125](media9/image-20220118181550125.png)

Рис.9.11. Копія екрану з 4-ма модулями.

- [ ] Зробіть експорт створеного операторського екрану в якусь доступну для редагування папку.
- [ ] Відкрийте файл експорту за допомогою текстового редактору, наприклад Notepad++.

Зміст файлу має формат XML. Враховуючи що кожен модуль на операторському екрані є групою з 9-ти елементів, варто знайти ці групи і візуально відокремити їх переносом рядку. 

- [ ] За допомогою інструментів пошуку знайдіть початок кожної групи, яка ідентифікується як `objectID="2"` та має 9 елементів.  Їх повинно бути 4.

![image-20220118182416754](media9/image-20220118182416754.png)

Рис.9.12. Початок групи для зображення модуля

- [ ] Відділіть початок групи новим рядком, щоб візуально вони відрізнялися.
- [ ] За допомогою інструментів пошуку та заміни, починаючи з групи для 2-го модуля, змініть `MODULES[0]` на вдповідно `MODULES[1]` ...`MODULES[3]` 
- [ ] Збережіть файл. Імпортуйте його в проект.
- [ ] Скопіюйте модулі на сторінку налагодження каналів.
- [ ] Скопіюйте на сторінку налагодження каналів групу що показує статусні біти ПЛК які були імпортовані раніше
- [ ] Видаліть усі зайві операторські екрани.

### 3.8. Перевірка роботи рівня 1 на операторських екранах

- [ ] Використовуючи операторський екран CM нижнього рівня:
  - [ ] подивіться стан змінних
  - [ ] перевірте роботу режиму форсування для кожного типу каналу (зверніть увагу на статусні біти ПЛК)

## 4. Встановлення утиліт для автоматизації розгортання

Каркас не передбачає обов'язкове використання утиліт розгортання, але це значно пришвидшує розробку. Тому в даній лабораторній роботі передбачається використання автоматичних утиліт розгортання [pacframework-tools](). 

- [ ] Встановіть утиліти, як це описано в [репозиторії](https://github.com/pupenasan/pacframework-tools)

## 5. Розгортання рівня змінних

- [ ] Завант

## 6. Розгортання рівня ВМ

- [ ] Завант

## 7. Перевірка програми користувача

- [ ] Завант

## Питання до захисту

1. Що таке програмний каркас? Які можливості надають програмні каркаси?
2. Навіщо програмні каркаси потрібні при розробці АСКТП?
3. Як програмний каркас АСКТП може вирішити проблему інтеграції з MES/MOM?
4. Як програмний каркас може допомогти в питанні покращення ситуаційної обізнаності?
5. Як програмний каркас може допомогти в питанні діагностики процесу (Alarm Management) та обладнання і усунення несправностей.
6. Як програмний каркас може допомогти при налагодженні системи?
7. Як програмний каркас може допомогти при навчання персоналу?
8. Розкажіть про основні ідеї PACFramework.
9. Розкажіть про ієрархію устатковання CM, яка використовується в PACFramework.
10. Розкажіть про організацію каналів (LVL0) та карту ПЛК в PACFramework.
11. Розкажіть про технологічні змінні (LVL1) та карту змінних в PACFramework.
12. Розкажіть про модулі керування, контури, ВМ (LVL2) в PACFramework.
13. Розкажіть про організацію рівня SCADA/HMI в PACFramework.
14. Розкажіть про принципи використання буферного обміну в PACFramework
15. Розкажіть про роль панелі статусу в PACFramework    

